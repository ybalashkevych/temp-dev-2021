---
globs: *Tests.swift,*Test.swift
alwaysApply: false
---

# Rules for unit tests

## Framework Selection & Migration
- **Prefer Swift Testing** (`import Testing`) for all new tests
- **Use `@Test` attribute** on it's own line for test methods instead of `test` prefix
- **Migrate existing XCTest gradually** - both frameworks can coexist in the same target
- **Only migrate XCTest to Swift Testing if explicitly asked to** - ok to keep older tests
- **Enable Testing Frameworks** in Build Settings for existing test targets

## Test Suite Structure
- **Prefer `struct` for test suites** without mutating `var` fields (automatic state isolation)
- **Use `class` when `deinit` cleanup is required or when `var` fields are necessary**
- **Initialize dependencies in `init()`** instead of `setUp()` methods
- **Use `deinit` for cleanup** instead of `tearDown()` methods (class/actor only)

## Test Organization & Setup
- **Keep repeated code to a minimum** - move common Fake initialization to `var` fields in the test class initializer
- **Initialize system under test in each test function** for clarity and isolation
- **Use factory methods** for creating test objects with different configurations
- **Group related tests** using test suite types or file organization

## Fake Dependency Management
- **Use `var` properties for Fake dependencies** in class-based test suites to allow reassignment
- **Reassign Fake instances in tests** that need specific data if accessing private properties is unavailable
- **Use Fake initializers** to set up test data if vars are private
- **Maintain test isolation** by creating fresh Fake instances or reassigning properties for each test
- **Avoid accessing private properties** of Fake implementations - use public interfaces or initializers
- **Prefer `var` over `let`** for Fake dependencies when they need to be reconfigured between tests

## Assertions & Expectations
- **Use `#expect()` for most validations** - provides detailed failure diagnostics
- **Use `async #expect()` when validating async functions**
- **Use `#require()` for critical preconditions** - aborts test immediately on failure
- **Replace `XCTUnwrap()` with `try #require()`** for safer optional unwrapping
- **Use standard Swift operators** (`==`, `!=`, `>`, `<`) instead of XCTest assertion functions

## Test Structure & Formatting
- **Use Arrange-Act-Assert pattern** with clear section comments
- **Add blank lines before section comments** to improve readability
- **Combine Act & Assert when appropriate** - No additional comments needed
- **Use descriptive test names** that explain the scenario being tested
- **Include test parameters in names** for parameterized tests

## Async & Concurrency Testing
- **Use `async/await` patterns** for asynchronous testing
- **Use `@MainActor`** for UI-related tests
- **Use `confirmation()` and `await fulfillment()`** for async expectations
- **Test Combine publishers** using output collectors and test schedulers

## Mocking & Test Doubles
- **Prefer manually coded Fakes** over Cuckoo-generated mocks (Cuckoo is being phased out)
- **Use `@OutputCollector`** for testing effects and side effects
- **Create reusable Fake implementations** in `AppCommon-TestUtilities`
- **Stub Fake results directly** on the instance rather than using complex mock setups

## Parameterized Testing
- **Use `@Test(arguments:)`** for testing multiple scenarios
- **Provide meaningful argument names** in test function parameters
- **Use `@Test(arguments:arguments:)`** for testing combinations of inputs
- **Consider using `@Suite`** for organizing related parameterized tests

## Error Testing
- **Use `#expect(throws: ErrorType)`** for testing thrown errors
- **Use `#expect(throws: Never.self)`** for testing that no error is thrown
- **Test specific error types** rather than generic error handling

## Performance & Parallel Execution
- **Enable parallel execution** in test plans (Swift Testing default)
- **Use `.serialized` trait** only for tests that cannot run in parallel
- **Avoid shared state** between tests to enable parallel execution
- **Test isolation is automatic** with Swift Testing's per-test suite instantiation

## Running Tests
- **Use `xcodebuild`** instead of `swift test` for most test targets
- **Confirm an iPhone simulator exists** when running tests for the first time
- **Always specify iPhone simulator explicitly** when running tests
- **Use package-specific schemes** for faster compilation of Swift Package tests

## Test Data & Fixtures
- **Create reusable test data** as computed properties or factory methods
- **Use realistic but minimal test data** that covers the test scenario
- **Avoid hardcoded magic numbers** - use named constants
- **Create test-specific models** when needed for clarity

## Documentation & Comments
- **Include standard copyright header** in all test files, see @copyright-header.mdc
- **Add comments for complex test scenarios** or business logic
- **Document test data setup** when it's not immediately obvious
- **Explain test expectations** in assertion messages when helpful

## Workflow & Troubleshooting
- **Limit test fix attempts to 3 iterations** before seeking help
- **Use test plan configurations** for different test scenarios
- **Enable code coverage** for test quality metrics
- **Run tests frequently** during development to catch issues early

## Migration Checklist
When migrating from XCTest to Swift Testing:
- [ ] Replace `XCTAssert` family with `#expect()` and `#require()`
- [ ] Convert `XCTUnwrap()` to `try #require()`
- [ ] Move `setUp()` logic to `init()`
- [ ] Move `tearDown()` logic to `deinit` (if using class)
- [ ] Replace `XCTestCase` with `struct` or `class`
- [ ] Update test method names (remove `test` prefix, add `@Test`)
- [ ] Convert async expectations to Swift Testing patterns
- [ ] Update error testing to use new syntax
