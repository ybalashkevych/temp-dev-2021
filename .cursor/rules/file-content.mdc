---
description: when create a new file *.swift file or modify existing ones
alwaysApply: false
---
# Swift File Content Rules

## Overview
All Swift files in this project must follow specific formatting requirements for copyright headers and file endings. These rules are enforced by SwiftLint and are critical for legal compliance and code quality.

## Required File Structure

### 1. Copyright Header (Required)
**Position**: Must be the very first content in the file, before any imports or other code.

**Template**:
```swift
//
//  [FileName].swift
//  LiveAssistant
//
//  Created by Yurii Balashkevych on [DATE]
//  Copyright © YYYY. All rights reserved.
//
```

**Requirements**:
- Use exact text, punctuation, and spacing as shown
- Replace `[FileName]` with the actual file name (e.g., `ContentView` for `ContentView.swift`)
- Replace `[DATE]` with the creation date in format `MM/DD/YY` (e.g., `10/12/25`)
- Replace `YYYY` with current 4-digit year (e.g., `2025`)
- No extra spaces or characters
- Header already ends with a blank line (the trailing `//` line)

### 2. File Ending (Required)
- **Must end with exactly one blank line** - no spaces, tabs, or other characters
- This is enforced by SwiftLint and shows as a warning in GitHub PRs

## Implementation Guidelines

### For New Files
1. Start with the copyright header
   - Replace `[FileName]` with the actual file name
   - Replace `[DATE]` with current date in `MM/DD/YY` format
   - Replace `YYYY` with current 4-digit year
2. Add imports (header already includes a blank line separator)
3. Write your code
4. End with exactly one blank line

### For Existing Files
- **Year Updates**: Update copyright year when making significant changes
- **Header Fixes**: Add missing headers or correct formatting
- **Ending Fixes**: Ensure file ends with exactly one blank line

### Common Scenarios

#### Creating a New Swift File
```swift
//
//  MyView.swift
//  LiveAssistant
//
//  Created by Yurii Balashkevych on 10/12/25
//  Copyright © 2025. All rights reserved.
//

import Foundation
import SwiftUI

struct MyView: View {
    var body: some View {
        Text("Hello World")
    }
}

```

#### Adding Header to Existing File
If a file is missing the header, add it at the very beginning:
```swift
//
//  [FileName].swift
//  LiveAssistant
//
//  Created by Yurii Balashkevych on [DATE]
//  Copyright © [Current Year]. All rights reserved.
//

// Existing imports and code below...
```

## Code Organization with Extensions

### Overview
To improve code readability and maintain clear separation of concerns, use Swift extensions to organize code within types. This approach makes large files more navigable and logically groups related functionality.

### Extension Usage Rules

**MUST use extensions for:**
1. **Protocol Conformances** - Each protocol should have its own extension
2. **Private Methods** - Group private methods by logical functionality
3. **Logically Separated Functionality** - When public/internal methods can be grouped by purpose

**CAN remain in main type body:**
- Properties (public, internal, private)
- Initializers
- Public and internal methods that are core to the type's primary purpose

### Organization Pattern

#### Basic Structure
```swift
// Main type definition
final class MyViewModel {
    // MARK: - Properties
    private let repository: MyRepositoryProtocol
    private(set) var state: ViewState = .idle
    
    // MARK: - Initialization
    init(repository: MyRepositoryProtocol) {
        self.repository = repository
    }
    
    // MARK: - Public Methods
    func loadData() async {
        // Core public functionality
    }
}

// MARK: - Protocol Conformance
extension MyViewModel: SomeProtocol {
    func protocolMethod() {
        // Protocol implementation
    }
}

// MARK: - Private Methods - Data Processing
private extension MyViewModel {
    func processData(_ data: [Item]) -> [ProcessedItem] {
        // Data processing logic
    }
    
    func validateData(_ data: [Item]) -> Bool {
        // Validation logic
    }
}

// MARK: - Private Methods - UI State Management
private extension MyViewModel {
    func updateUIState(_ state: ViewState) {
        // UI state updates
    }
    
    func handleError(_ error: Error) {
        // Error handling
    }
}
```

#### Multiple Protocol Conformances
```swift
struct ContentView: View {
    @State private var vm: ContentViewModel
    
    var body: some View {
        // View implementation
    }
}

// MARK: - Equatable
extension ContentView: Equatable {
    static func == (lhs: ContentView, rhs: ContentView) -> Bool {
        // Equatable implementation
    }
}

// MARK: - Identifiable
extension ContentView: Identifiable {
    var id: String {
        // Identifiable implementation
    }
}
```

#### Service/Repository Organization
```swift
final class TranscriptionService: TranscriptionServiceProtocol {
    // MARK: - Properties
    private let recognizer: SFSpeechRecognizer
    private let audioEngine: AVAudioEngine
    
    // MARK: - Initialization
    init() {
        // Initialization
    }
    
    // MARK: - Public API
    func startTranscription() async throws {
        // Public method
    }
    
    func stopTranscription() {
        // Public method
    }
}

// MARK: - Private Methods - Audio Setup
private extension TranscriptionService {
    func configureAudioEngine() {
        // Audio configuration
    }
    
    func setupInputNode() {
        // Input setup
    }
}

// MARK: - Private Methods - Recognition
private extension TranscriptionService {
    func createRecognitionRequest() -> SFSpeechAudioBufferRecognitionRequest {
        // Request creation
    }
    
    func handleRecognitionResult(_ result: SFSpeechRecognitionResult) {
        // Result handling
    }
}
```

### Guidelines for Logical Grouping

When organizing private methods into extensions, group by:

1. **Functionality Domain**
   - Data processing
   - Network operations
   - State management
   - UI updates
   - Validation

2. **Data Flow Stage**
   - Input handling
   - Data transformation
   - Output formatting
   - Error handling

3. **System Integration**
   - Audio operations
   - Permission handling
   - File operations
   - API communication

### MARK Comments

**MUST:**
- Use `// MARK: - ` prefix for all extension headers
- Use descriptive, specific names for private method groups
- Be consistent with MARK comment style across the file

**Examples:**
```swift
// MARK: - Protocol Conformance
// MARK: - Equatable
// MARK: - Private Methods - Audio Processing
// MARK: - Private Methods - State Management
// MARK: - Private Methods - Error Handling
```

### Benefits

1. **Improved Readability**
   - Clear visual separation between different concerns
   - Easier to scan and navigate large files
   - MARK comments create navigable sections in Xcode

2. **Better Organization**
   - Related functionality grouped together
   - Protocol conformances isolated and easy to find
   - Private implementation details separated from public API

3. **Enhanced Maintainability**
   - Changes to private logic don't clutter main type definition
   - Easy to add new protocol conformances
   - Logical grouping helps identify refactoring opportunities

4. **Code Review Benefits**
   - Reviewers can quickly understand code structure
   - Protocol conformances are immediately visible
   - Changes are easier to contextualize

### Consistency Across Layers

This organization pattern applies to all layers:
- **Views**: Separate view body from helper methods and protocol conformances
- **ViewModels**: Separate public API from private implementation
- **Repositories**: Group data source interactions and transformations
- **Services**: Organize system integrations and internal logic

## Validation

### SwiftLint Enforcement
- Missing or incorrect headers are treated as **errors**
- Missing blank line at end is treated as **error**
- Run `swiftlint` locally before committing

### GitHub PR Checks
- File ending issues show as warnings in PRs
- Copyright header issues block PRs

## Best Practices

1. **Year Management**: Update copyright year when making significant changes
2. **Consistency**: Use exact header format across all files
3. **Verification**: Always run SwiftLint before committing
4. **Automation**: Consider using SwiftFormat for automatic formatting
5. **Documentation**: Update this file when adding new exclusions

## Quick Reference

| Requirement | Position | Format |
|-------------|----------|---------|
| Copyright Header | First content in file | Xcode-style header with file name, date, and year |
| Blank Line After Header | After header, before imports | Included in header (trailing `//`) |
| File Ending | End of file | Exactly one blank line |
| Imports | After blank line | Standard Swift import statements |

